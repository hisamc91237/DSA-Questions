Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]

APPROACH : TC : O(n)

class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {

        // check 
        if(head == NULL || k == 1) return head;

        // creating dummy Node
        ListNode* dummy = new ListNode(0);
        dummy -> next = head;

        // Assign all nodes
        ListNode* cur = dummy , *nex = dummy , *pre = dummy;

        int cnt = 0; // to count the nodes

        // length of Ll
        ListNode* temp = head;
        while(temp != NULL){
            temp = temp -> next;
            cnt++;
        }

        // traverse till cnt is more than k
         while(cnt >= k){
             cur = pre -> next;
             nex = cur -> next;

             // loop for k group
             for(int i = 1 ; i < k;i++){

                // Algo 
                 cur -> next = nex -> next;
                 nex -> next = pre -> next;
                 pre -> next = nex;
                 nex = cur -> next;
             }

             pre = cur;
             cnt -= k;
         }

        return dummy -> next;
        
    }
};

